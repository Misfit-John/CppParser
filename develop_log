2015/6/24
Log1:	宏定义对于空格的处理优点特别
		#define hell (a) //将被认为是一个define，hell的内容将被替换成(a)
		#define hell(a) //将被认为是一个define, hell(x)的内容被替换成空白。
		他们的差异就是中间有没有空格。所以c语言里面的空格还是不能完全忽略的

2015/6/21
Log1:	重写define mngr，这个东西不能直接返回string。或者说，应该直接返回lex record比较好.

2015/6/19
Log1:	preprocess过程开始就应该使用语法分析器进行分析了。
		不应该在一个for里面判断一堆if

2015/6/18
Log1:	真心不知道怎么写了。。。include的头文件扩展之后怎么替换旧的root

2015/6/17
Log1:	#define允许重定义，但是以最后一个定义为准
Log2:	#define在定义的时候并不关心是否能翻译。只是在展开的时候关心是否已经定义。并且定义里面调用定义也是在展开的时候看的。例如下面的代码是可以编译通过的：
例如下面的代码是可以编译通过的
	File: marco.cpp

	#include <stdio.h>

	#define b() a()
	#define a() {printf("hello\n");}
	#define hello a()

	int main(int argc, const char *argv[])
	{
		hello;
		b();
		return 0;
	}

	File end :marco.cpp

但是另一方面，如果展开的时候出现循环，就会重现无法扩展。原因是宏定义只能展开一次。例如下面的代码无法编译通过:	
	File: marco_error.cpp

	#include <stdio.h>
	//间接出现循环
	#define b() a()
	#define a() {printf("hello\n");b();}
	#define hello a()

	int main(int argc, const char *argv[])
	{
		hello;
		b();
		return 0;
	}

	File end :marco_error.cpp

	File: marco_error2.cpp

	#include <stdio.h>

	//直接循环
	#define a() {printf("hello\n");a();}
	#define hello a()

	int main(int argc, const char *argv[])
	{
		hello;
		return 0;
	}

	File end :marco_error2.cpp

Log3: 并非所有define都是直接拓展的。下面的代码将会报错：
	File marco_error3.cpp
	
	#include <stdio.h>

	#define hello " 123+ 1

	int main(int argc, const char *argv[])
	{
		printf("%s", hello ");
		return 0;
	}

	File end :marco_error3.cpp
2015/6/16
Log1:	include并非完全是把头文件拓展开来。\的影响不会从上一个文件继承到下一个文件

2015/5/25
Log1:	感觉可能不需要独立写注释去处管理。应该在词法分析之后进行注释移除就可以了
Log2:	还是不太明白要怎么处理backSlant


