2015/7/28
Log1:	处理#if宏的时候，如果遇到未定义的宏，则全部解析成0

2015/7/25
Log1:	总算处理掉#ifdef,#else,#endif三个宏了。。。现在考虑#if,#elif的逻辑怎判断。。。心好塞，这里就要处理逻辑了吗

2015/7/11
Log1:	项目重开，词法分析器与预编译过程进行合并重写。使用pattern进行重写。方便拓展的那种

2015/7/7
Log1:	本项目重写

断片：突然在预处理这里卡住了。。。相信很长一段时间不会继续往下写了，因为不知道怎么写啊。。。容我想明白先

2015/6/30
Log1:	宏定义的连接符号##，对于前后都是参数的情况，会先替换参数。否则会直接连接
Log2:	连接符强制将两个参数黏合在一起。注意是粘合
		File : macro_test.cpp
		#include <stdio.h>

		#define hello(a,b,c) printf("a %d",b## 3)

		class helcal {
		public:
			helcal ()
			{
			}
			virtual ~helcal (){};
		};

		int main(int argc, const char *argv[])
		{
			int abcdef = 10;
			hello(1,1<<1,2);
			return 0;
		}
		File end:macro_test.cpp
		上述文件将输出
		a 8192
		(不带回车)为何会出现这个输出，是因为连接符将1<<1跟3连接在了一起，变成了1<<13。所以左移了13位，变成了8192
		值得注意的是，这个连接符前后有没有空格并不影响计算结果

Log3:	我觉得我还是重新写一次预编译过程比较好。。。。先不管了，还是按照现在这样写。编译过程对于string的保持不对并不影响编译结果，所以保持不变，不动。
Log4:	总的来说，宏定义的处理不会垮文件
Log5:	注意，除了使用__VA_ARGS__以外，还可以自定义变参列表名。。。

2015/6/29
Log1:	宏函数参数读取结束。现在想想怎么做参数替换。。。直接替换的部分倒是挺简单的，问题是还有#和##。。。

2015/6/26
Log1:	宏函数的参数说白了也不过是计算表达式。所以我这是要先研究怎么解析计算表达式的节奏吗。。。
		有一个比较折衷的方案就是，直接解析括号，以及尖括号，单引号和双引号对这几对符号进行亚栈配对。其他的符号貌似不会引起逗号的存在。
		只要这两个符号匹配结果正确，就可以压入参数

2015/6/25
Log1:	wtf函数宏定义展开为何如此烦烦烦烦。。。。。需要进一步探究到底哪些可以做参数哪些不可以

2015/6/24
Log1:	宏定义对于空格的处理优点特别
		#define hell (a) //将被认为是一个define，hell的内容将被替换成(a)
		#define hell(a) //将被认为是一个define, hell(x)的内容被替换成空白。
		他们的差异就是中间有没有空格。所以c语言里面的空格还是不能完全忽略的

2015/6/21
Log1:	重写define mngr，这个东西不能直接返回string。或者说，应该直接返回lex record比较好.

2015/6/19
Log1:	preprocess过程开始就应该使用语法分析器进行分析了。
		不应该在一个for里面判断一堆if

2015/6/18
Log1:	真心不知道怎么写了。。。include的头文件扩展之后怎么替换旧的root

2015/6/17
Log1:	#define允许重定义，但是以最后一个定义为准
Log2:	#define在定义的时候并不关心是否能翻译。只是在展开的时候关心是否已经定义。并且定义里面调用定义也是在展开的时候看的。例如下面的代码是可以编译通过的：
例如下面的代码是可以编译通过的
	File: marco.cpp

	#include <stdio.h>

	#define b() a()
	#define a() {printf("hello\n");}
	#define hello a()

	int main(int argc, const char *argv[])
	{
		hello;
		b();
		return 0;
	}

	File end :marco.cpp

但是另一方面，如果展开的时候出现循环，就会重现无法扩展。原因是宏定义只能展开一次。例如下面的代码无法编译通过:	
	File: marco_error.cpp

	#include <stdio.h>
	//间接出现循环
	#define b() a()
	#define a() {printf("hello\n");b();}
	#define hello a()

	int main(int argc, const char *argv[])
	{
		hello;
		b();
		return 0;
	}

	File end :marco_error.cpp

	File: marco_error2.cpp

	#include <stdio.h>

	//直接循环
	#define a() {printf("hello\n");a();}
	#define hello a()

	int main(int argc, const char *argv[])
	{
		hello;
		return 0;
	}

	File end :marco_error2.cpp

Log3: 并非所有define都是直接拓展的。下面的代码将会报错：
	File marco_error3.cpp
	
	#include <stdio.h>

	#define hello " 123+ 1

	int main(int argc, const char *argv[])
	{
		printf("%s", hello ");
		return 0;
	}

	File end :marco_error3.cpp
2015/6/16
Log1:	include并非完全是把头文件拓展开来。\的影响不会从上一个文件继承到下一个文件

2015/5/25
Log1:	感觉可能不需要独立写注释去处管理。应该在词法分析之后进行注释移除就可以了
Log2:	还是不太明白要怎么处理backSlant


